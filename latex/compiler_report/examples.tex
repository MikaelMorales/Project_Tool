
Value class signatures are similar to class signatures in tool, with the keyword class preceded by \textbf{@value}, to differentiate a value class declaration from a standard class declaration. \newline
Unlike scala, a value class does not have to extends AnyVal, we choose to forbid value classes to extends anything, and as in scala, value classes cannot be extended.\newline
A value class can only contain strictly one field, which needs to be declared at the beginning of the value class, and then followed by method implementations. The field of a value class object cannot be modified after the instantiation of the object.\newline

First of all, a very simple example of a value class which shows how a value class behaves with a primitive type field. The user creates an instance of the value class A, and initializes the field of the class A to 2, and called the method sayHello defined in the value class A which returns "Hello" concatenated with the field, so in this case it returns "Hello2".

\lstinputlisting[language=tool]{BasicValueClass.tool}

The generated bytecode is the following.

\begin{lstlisting}
public static void main(java.lang.String[]);
Code:
   0: getstatic     #19 
   3: iconst_2               // Push the constant 2 
   4: invokestatic  #25      // Method A.sayHello:(I)Ljava/lang/String;
   7: invokevirtual #31 
  10: return


public class A {
  protected int x;

  static java.lang.String sayHello(int);
  Code:
     0: new           #13
     3: dup
     4: invokespecial #17
     7: ldc           #19      // String Hello
     9: invokevirtual #23
    12: iload_0
    13: invokevirtual #26
    16: invokevirtual #30
    19: areturn
}
\end{lstlisting}

We can see that the instantiation of Test(2) doesn't allocate any memory in the heap. 
It only results in pushing the constant 2 on the stack. \newline
Since we don't allocate the instance of the class on the heap, we declare all the methods of a value class as static. Moreover, we modify the method's signature to pass the field of the value class so they can access it.

The field of a value class can be of any type that is allowed in Tool (Bool, String, Int, Int[], Class and another value class). Here is an example with several value classes and a class C as a root field.

\lstinputlisting[language=tool]{SimpleValClassExample.tool}

The generated bytecode is the following.

\begin{lstlisting}
public static void main(java.lang.String[]);
Code:
   0: getstatic     #19                 
   3: new           #21      // class C
   6: dup
   7: invokespecial #22      // Method C."<init>":()V
  10: invokestatic  #28      // Method A.get:(LC;)I
  13: invokevirtual #34                 
  16: return
\end{lstlisting}

As you can see if the field is an object (Class, String or arrays), we allocate memory only for the field and not the value class. \newline
Furthermore, if multiple value classes are wrapped between each other, we recursively fetch the field until we reach a non value class field.
\newpage
\lstinputlisting[language=tool]{SimpleThisTest.tool}

The generated bytecode is the following.

\begin{lstlisting}
public static void main(java.lang.String[]);
Code:
   0: getstatic     #19                 
   3: iconst_5               // Push the constant 5
   4: invokestatic  #25      // Method A.foo:(I)I
   7: invokestatic  #25      // Method A.foo:(I)I
  10: invokestatic  #25     // Method A.foo:(I)I
  13: invokestatic  #25     // Method A.foo:(I)I
  16: invokestatic  #28     // Method A.compute:(I)I
  19: invokevirtual #34                 
  22: return

public class A {
  protected int s;

  static int compute(int);
    Code:
       0: iload_0
       1: ireturn

  static int foo(int);
    Code:
       0: iload_0
       1: ireturn
}
\end{lstlisting}
Here we can see that when calling the method foo which returns this, we only push the field on the stack which allows us to concatenate calls of the method foo. Each call to the method foo uses the field which was pushed by the previous call of foo() as an argument.

